name: CI
on:
  push:
    branches:
      - '*'
    tags:
      - v[0-9]+.[0-9]+

  release:
    types:
      - published

env:
  team: team
  image_pull_secret_acr: sravni-azurecr-io

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    outputs:
      build_number: ${{ env.build_number }}
      branch: ${{ env.branch }}

    steps:

      - name: Checkout source
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Set build vars to GITHUB_ENV
        run: |
          svc=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
          echo "service_name=$svc" >> $GITHUB_ENV

          raw=$(git branch -r --contains ${{ github.ref }})
          branch=${raw##*/}
          echo "branch=${branch}" >> $GITHUB_ENV

          sha=$(echo ${GITHUB_SHA} | cut -c1-7)
          case $branch in
           master)
               build_number=$sha
               ;;
           *)
               build_number="${sha}-qa"
          esac
          echo "build_number=${build_number}" >> $GITHUB_ENV

          image_name="${{ secrets.CONTAINER_REGISTRY }}/${svc}:${build_number}"
          image_latest="${{ secrets.CONTAINER_REGISTRY }}/${svc}:latest"
          echo "image_name=${image_name}" >> $GITHUB_ENV
          echo "image_latest=${image_latest}" >> $GITHUB_ENV

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Check if image already exists
        run: |
          image_exists=$(docker manifest inspect "${{ env.image_name }}" > /dev/null; echo $?)
          echo "image_exists=${image_exists}" >> $GITHUB_ENV

          if [ "${image_exists}" == 1 ]
          then
            pull_latest=$(docker pull "${image_latest}" > /dev/null; echo $?)
          fi

      - name: Validate values files
        if: ${{ env.image_exists == 1 }}
        uses: addnab/docker-run-action@v3
        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app
          run: |
            for file in /app/.k8s/*.yaml;
            do
              yamale -s /charts/generic-application/schema.yaml $file
            done

      - name: Docker build
        if: ${{ env.image_exists == 1 }}
        id: docker_build
        uses: docker/build-push-action@v2
        with:
          context: .
          file: Dockerfile
          build-args: |
            GITHUB_NPM_TOKEN=${{ secrets.GH_TOKEN }}
            build_number=${{ env.build_number }}
          push: false
          tags: "${{ env.image_name }}"

      - name: Trivy Scanning
        if: ${{ env.image_exists == 1 }}
        run: |
          docker run \
          -v /var/run/docker.sock:/var/run/docker.sock:rw \
          -v /trivy/cache:/tmp/trivy/db \
          aquasec/trivy:${{ secrets.TRIVY_VERSION }} \
          --cache-dir /tmp/trivy/ \
          --severity CRITICAL,HIGH \
          --no-progress \
          --ignore-unfixed \
          --exit-code 0 "${{ env.image_name }}"

      - name: Docker Push
        if: ${{ env.image_exists == 1 }}
        run: |
          branch=${GITHUB_REF#refs/heads/}
          docker push "${{ env.image_name }}"
          if [ $branch = "master" ]
          then
              docker tag "${{ env.image_name }}" "${{ env.image_latest }}"
              docker push "${{ env.image_latest }}"
          fi

          echo "BUILD_STATE=successful" >> $GITHUB_ENV

      - name: Failed Build
        if: ${{ failure() }}
        run: echo "BUILD_STATE=failed" >> $GITHUB_ENV

      - name: Parse Jira Keys from Commit
        id: jira_keys
        if: ${{ always() }}
        uses: HighwayThree/jira-extract-issue-keys@master
        with:
          is-pull-request: ${{ github.event_name == 'pull_request' }}
          parse-all-commits: ${{ github.event_name == 'push' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Push Build Info to Jira
        if: steps.jira_keys.outputs.jira-keys != ''
        id: push_build_info_to_jira
        uses: HighwayThree/jira-upload-build-info@master
        with:
          cloud-instance-base-url: 'https://sravniru.atlassian.net'
          client-id: '${{ secrets.JIRA_CLIENT_ID }}'
          client-secret: '${{ secrets.JIRA_CLIENT_SECRET }}'
          pipeline-id: '${{ github.repository }} ${{ github.workflow }}'
          build-number: ${{ github.run_number }}
          build-display-name: 'Workflow: ${{ github.workflow }} (#${{ github.run_number }})'
          build-state: "${{ env.BUILD_STATE }}"
          build-url: 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          update-sequence-number: '${{ github.run_id }}'
          last-updated: '${{ github.event.head_commit.timestamp }}'
          issue-keys: "${{ steps.jira_keys.outputs.jira-keys }}"
          commit-id: '${{ github.sha }}'
          repo-url: '${{ github.event.repository.url }}'
          build-ref-url: 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'

      - name: Confirm Jira Build Output
        if: ${{ success() }}
        run: |
          echo "Jira Upload Build Info response: ${{ steps.push_build_info_to_jira.outputs.response }}"


  publish_to_stage:
    runs-on: ubuntu-latest
    needs: [ build_and_test ]
    env:
      build_number: ${{ needs.build_and_test.outputs.build_number }}
      branch: ${{ needs.build_and_test.outputs.branch }}

    steps:
      - name: Set service name to GITHUB_ENV
        id: set_service_name
        run: |
          # этот шаг задублирован из джобы build_and_test, потому что гитхаб считает
          # что в нем лежит какой-то секрет и не даёт его передать в качестве аутпута
          # предыдущей джобы

          svc=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
          echo "service_name=$svc" >> $GITHUB_ENV

      - name: Get namespace name
        id: get_namespace
        run: |
          echo "Current branch is ${{ env.branch }}"
          namespace=$(echo ${{ env.branch }} | awk -F '/' '{print $NF}')
          namespace=${namespace,,}

          regexp='^|[a-z|]|[-a-z0-9|]{1,12}|[a-z0-9|]$'

          if echo $namespace | grep -Eq $regexp; then
              echo "${namespace} is valid name"
          else
            echo "Only: letters, numbers, no more than 14 characters";
            exit 1;
          fi

          echo "namespace=${namespace}" >> $GITHUB_ENV

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Checkout source
        uses: actions/checkout@v2

      - name: Check if namespace already exists
        run: |
          RESPONSE_FILE=/tmp/$(uuidgen).txt

          qa_envs_route="${{ secrets.QA_API_URL }}/environments"
          env_name=${{ env.namespace }}


          get_response=$(curl -X GET -so "${RESPONSE_FILE}" -w "%{http_code}" ${qa_envs_route}/${env_name} \
          --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
          -H "accept: application/json" || true)

          namespace_exists=0

          if [ $get_response == "200" ]; then
           echo "Environment ${env_name} already exists"
           namespace_exists=1

          elif [ $get_response != "404" ]; then
           echo "Server returned:"
           cat "${RESPONSE_FILE}" && exit 1
          fi

          echo "namespace_exists=${namespace_exists}" >> $GITHUB_ENV

      - name: Create namespace
        if: ${{ env.namespace_exists == 0 }}
        uses: addnab/docker-run-action@v3
        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: -w=/charts/qa-environment-helpers
          run: |
            if [[ "${env_name}" != "master" ]]; then
              echo ${{ secrets.YANDEX_KEY }} | base64 --decode > /key.json

              yc config profile create github
              yc config set service-account-key /key.json
              yc managed-kubernetes \
                cluster get-credentials \
                --cloud-id ${{ secrets.YANDEX_CLOUD_ID }} \
                --folder-id ${{ secrets.YANDEX_FOLDER_ID }} \
                yc-stage-k8s --external

              RESPONSE_FILE=/tmp/$(uuidgen).txt

              qa_envs_route="${{ secrets.QA_API_URL }}/environments"
              env_name=${{ env.namespace }}

              put_response=$(curl -X PUT \
                -so "${RESPONSE_FILE}" \
                -w "%{http_code}" $qa_envs_route \
                -H "accept: application/json" \
                -H "Content-Type: application/json" \
                --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
                -d "{ \"createdBy\": \"${{ github.actor }}\", \"kind\": \"QA\", \"name\": \"${env_name}\", \"team\": \"${{ env.team }}\"}")

              if [ "${put_response}" != "200" ]; then
                echo "Cannot create environment ${env_name}"
                cat "${RESPONSE_FILE}" && exit 1
              fi

              echo "Environment ${env_name} has been created"
              # substitute the environment name inside the new-namespace-yandex.yml file
              export EnvironmentName=$env_name
              cat /charts/qa-environment-helpers/k8s-manifests/new-namespace-yandex.yml | envsubst | kubectl apply -f - 1>/dev/null 2>/dev/null
              echo "Manifest has been applied"

              /bin/bash /charts/qa-environment-helpers/scripts/identity-key/new-identity-key.sh
              echo "Identity key has been generated"

              kubectl -n ${env_name} create secret generic identity-key --from-file identity.pfx
              echo "Identity key secret has been created"
              kubectl -n ${env_name} create secret generic labs-identity-key --from-file identity.pfx
              echo "Labs identity key secret has been created"
            fi

      - name: Publish
        uses: addnab/docker-run-action@v3

        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/helm-charts:${{ secrets.HELM_CHARTS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app -w=/app
          run: |
            echo ${{ secrets.YANDEX_KEY }} | base64 --decode > /key.json

            yc config profile create github
            yc config set service-account-key /key.json

            yc managed-kubernetes \
              cluster get-credentials \
              --cloud-id ${{ secrets.YANDEX_CLOUD_ID }} \
              --folder-id ${{ secrets.YANDEX_FOLDER_ID }} \
              yc-stage-k8s --external

            echo "Trying to deploy ${{ env.service_name }}..."

            werf helm upgrade --install \
              "${{ env.service_name }}" \
              --namespace "${{ env.namespace }}" \
              --timeout 10m \
              --wait \
              --set global.image.repository="${{ secrets.CONTAINER_REGISTRY }}/${{ env.service_name }}" \
              --set global.image.tag="${{ env.build_number }}" \
              --set global.imagePullSecrets[0]="${{ env.image_pull_secret_acr }}" \
              --set cronjobs.defaults.resources.enabled=false \
              --set resources.enabled=false \
              --set replicaCount=1 \
              -f ./.k8s/ya-stage.yaml \
              /charts/generic-application/ \
              2>&1

            if [ $? != 0 ]; then
              echo "Publish failed, see logs" && exit 1
            fi

            echo "Done"

      - name: Failed Deployment
        if: ${{ failure() }}
        run: echo "DEPLOY_STATE=failed" >> $GITHUB_ENV

      - name: Set info about deployment to qa-environment-service
        if: ${{ success() }}
        run: |
          echo "DEPLOY_STATE=successful" >> $GITHUB_ENV

          qa_deps_route="${{ secrets.QA_API_URL }}/deployments"

          RESPONSE_FILE=/tmp/$(uuidgen).txt

          put_response=$(curl -X PUT \
            -so "${RESPONSE_FILE}" \
            -w "%{http_code}" "${qa_deps_route}" \
            -H "accept: application/json" \
            -H "Content-Type: application/json" \
            --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
            -d "{ \
               \"Branch\": \"${{ env.branch }}\", \
               \"Project\": \"${{ env.service_name }}\", \
               \"Stand\": \"${{ env.namespace }}\", \
               \"TriggeredBy\": \"${{ github.actor }}\", \
               \"VcsNumber\": \"${{ env.build_number }}\", \
               \"buildId\": ${{ github.run_id }} \
               }" \
          || true )

          if [ "${put_response}" == "200" ]; then
            echo "Deployment creation OK"
            exit 0
          elif [ "${put_response}" == "409" ]; then
            echo "Deployment already exists"
            exit 0
          else
            echo "Cannot create deployment"
            echo "${put_response}"
            cat "${RESPONSE_FILE}" && exit 1
          fi

      - name: Parse Jira Keys from All Commits
        id: jira_keys
        if: ${{ always() }}
        uses: HighwayThree/jira-extract-issue-keys@master
        with:
          is-pull-request: ${{ github.event_name == 'pull_request' }}
          parse-all-commits: ${{ github.event_name == 'push' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Confirm Deploy State and Jira Key Values
        if: ${{ always() }}
        run: |
          echo "DEPLOY_STATE: ${{env.DEPLOY_STATE}}"
          echo "Jira Keys: ${{ steps.jira_keys.outputs.jira-keys }}"

      - name: Push Deployment Info to Jira
        if: steps.jira_keys.outputs.jira-keys != ''
        id: push_deployment_info_to_jira
        uses: HighwayThree/jira-upload-deployment-info@master
        with:
          cloud-instance-base-url: 'https://sravniru.atlassian.net'
          client-id: '${{ secrets.JIRA_CLIENT_ID }}'
          client-secret: '${{ secrets.JIRA_CLIENT_SECRET }}'
          deployment-sequence-number: '${{ github.run_id }}'
          update-sequence-number: '${{ github.run_id }}'
          issue-keys: "${{ steps.jira_keys.outputs.jira-keys }}"
          display-name: "Deployment number ${GITHUB_SHA}"
          url: "${{ github.event.repository.url }}/actions/runs/${{ github.run_id }}"
          description: "Test Deployment"
          last-updated: '${{ github.event.head_commit.timestamp }}'
          label: 'Test Deployment Label'
          state: '${{ env.DEPLOY_STATE }}'
          pipeline-id: '${{ github.repository }} ${{ github.workflow }}'
          pipeline-display-name: 'Workflow: ${{ github.workflow }} (#${{ github.run_number }})'
          pipeline-url: 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          environment-id: 'Test'
          environment-display-name: 'Test'
          environment-type: 'testing'

      - name: Confirm Jira Deploy Output
        if: ${{ success() }}
        run: |
          echo "Jira Upload Deploy Info response: ${{steps.push_deployment_info_to_jira.outputs.response}}"


  publish_to_azure:
    if: ${{ false }}
#    if: startsWith(github.ref, 'refs/tags') || contains(github.event_name, 'release')

    needs:
      - 'build_and_test'
      - 'publish_to_stage'

    runs-on: ubuntu-latest

    env:
      build_number: ${{ needs.build_and_test.outputs.build_number }}

    steps:
      - name: Set service name to GITHUB_ENV
        id: set_service_name
        run: |
          # этот шаг задублирован из джобы build_and_test, потому что гитхаб считает
          # что в нем лежит какой-то секрет и не даёт его передать в качестве аутпута
          # предыдущей джобы

          svc=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
          echo "service_name=$svc" >> $GITHUB_ENV

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Checkout source
        uses: actions/checkout@v2

      - name: Publish
        uses: addnab/docker-run-action@v3

        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app -w=/app
          run: |
            az login --service-principal \
              --username ${{ secrets.ARM_CLIENT_ID }} \
              --password ${{ secrets.ARM_CLIENT_SECRET }} \
              --tenant ${{ secrets.ARM_TENANT_ID }}

            az aks get-credentials --admin \
              --resource-group sravni \
              --name az-prod-k8s
            echo "Deploying service ${{ env.service_name }}..."

            werf helm upgrade --install \
             "${{ env.service_name }}" \
             --namespace sravni \
             --atomic \
             --timeout 10m \
             --set global.image.repository="${{ secrets.CONTAINER_REGISTRY }}/${{ env.service_name }}" \
             --set global.image.tag="${{ env.build_number }}" \
             --set global.imagePullSecrets[0]="${{ env.image_pull_secret_acr }}" \
             --set azureRedis.uri=${{ secrets.AZURE_REDIS_URI }} \
             --set linkerd.enabled=false \
             -f ./.k8s/azure.yaml \
             /charts/generic-application/

            if [ $? != 0 ]; then
              echo "Publish failed, see logs" && exit 1
            fi

            echo "Done"

      - name: Failed Deployment
        if: ${{ failure() }}
        run: echo "DEPLOY_STATE=failed" >> $GITHUB_ENV

      - name: Inform about release
        if: ${{ success() }}
        run: |
          echo "DEPLOY_STATE=successful" >> $GITHUB_ENV

          sha=$(echo ${GITHUB_SHA} | cut -c1-7)

          curl -XPOST \
            ${{ secrets.RELEASE_NOTIFIER_URL }} \
            -d '{
              "build_id": "${{ github.run_id }}",
              "version": "${sha}",
              "build_status_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }'

      - name: Parse Jira Keys from All Commits
        id: jira_keys
        if: ${{ always() }}
        uses: HighwayThree/jira-extract-issue-keys@master
        with:
          is-pull-request: ${{ github.event_name == 'pull_request' }}
          parse-all-commits: ${{ github.event_name == 'push' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Confirm Deploy State and Jira Key Values
        if: ${{ always() }}
        run: |
          echo "DEPLOY_STATE: ${{ env.DEPLOY_STATE }}"
          echo "Jira Keys: ${{ steps.jira_keys.outputs.jira-keys }}"

      - name: Push Deployment Info to Jira
        if: steps.jira_keys.outputs.jira-keys != ''
        id: push_deployment_info_to_jira
        uses: HighwayThree/jira-upload-deployment-info@master
        with:
          cloud-instance-base-url: 'https://sravniru.atlassian.net'
          client-id: '${{ secrets.JIRA_CLIENT_ID }}'
          client-secret: '${{ secrets.JIRA_CLIENT_SECRET }}'
          deployment-sequence-number: '${{ github.run_id }}'
          update-sequence-number: '${{ github.run_id }}'
          issue-keys: "${{ steps.jira_keys.outputs.jira-keys }}"
          display-name: "Deployment number ${GITHUB_SHA}"
          url: "${{ github.event.repository.url }}/actions/runs/${{ github.run_id }}"
          description: "Prod Deployment"
          last-updated: '${{ github.event.head_commit.timestamp }}'
          label: 'Prod Deployment Label'
          state: '${{ env.DEPLOY_STATE }}'
          pipeline-id: '${{ github.repository }} ${{ github.workflow }}'
          pipeline-display-name: 'Workflow: ${{ github.workflow }} (#${{ github.run_number }})'
          pipeline-url: 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          environment-id: 'Prod'
          environment-display-name: 'Prod'
          environment-type: 'production'
