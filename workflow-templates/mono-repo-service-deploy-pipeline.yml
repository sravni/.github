name: CD pipeline
on:
  push:
    branches:
      - '*'
    tags:
      - v[0-9]+.[0-9]+

  release:
    types:
      - published

env:
  team: team
  image_pull_secret_acr: sravni-azurecr-io

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    # runs-on: sravni_ycloud_stage, если тестам нужен доступ к инфре
    outputs:
      branch: ${{ env.branch }}
      author: ${{ steps.get-ids.outputs.author }}
      committer: ${{ steps.get-ids.outputs.committer }}
      build_number: ${{ env.build_number }}

    steps:
      # удалить как выставите team на значение своей команды
      - name: Check if team variable is set
        run: |
          if [[ "${{ env.team }}" == "team" ]]; then
            echo "Change the value of the `team` variable, start again";
            exit 1;
          fi

      - name: Checkout source
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Expose git commit data
        uses: rlespinasse/git-commit-data-action@1.1.2

      - name: Get ids
        id: get-ids
        run: |
          set -x

          committer=${{ env.GIT_COMMIT_COMMITTER_EMAIL }}

          if [[ $committer == *sravni.ru ]]; then
            committer=$(echo $committer | awk -F@ '{print $1}')
          else
            committer="${{ env.GIT_COMMIT_COMMITTER_EMAIL }}"
          fi

          author=${{ env.GIT_COMMIT_AUTHOR_EMAIL }}

          if [[ $author == *sravni.ru ]]; then
            author=$(echo $author | awk -F@ '{print $1}')
          else
            author="${{ env.GIT_COMMIT_AUTHOR_EMAIL }}"
          fi

          echo "::set-output name=author::${author}"
          echo "::set-output name=committer::${committer}"

      - name: Set build vars to GITHUB_ENV
        run: |
          svc=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
          echo "service_name=$svc" >> $GITHUB_ENV

          raw=$(git branch -r --contains ${{ github.ref }})
          branch=${raw##*/}
          echo "branch=${branch}" >> $GITHUB_ENV

          sha=$(echo ${GITHUB_SHA} | cut -c1-7)
          case $branch in
           master)
               build_number=$sha
               ;;
           *)
               build_number="${sha}-qa"
          esac
          echo "build_number=${build_number}" >> $GITHUB_ENV

          image_name="${{ secrets.CONTAINER_REGISTRY }}/${svc}:${build_number}"
          image_latest="${{ secrets.CONTAINER_REGISTRY }}/${svc}:latest"
          echo "image_name=${image_name}" >> $GITHUB_ENV
          echo "image_latest=${image_latest}" >> $GITHUB_ENV

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Check if image already exists
        run: |
          # exists = 0, not exists = 1
          image_exists=$(docker manifest inspect "${{ env.image_name }}" > /dev/null; echo $?)
          echo "image_exists=${image_exists}" >> $GITHUB_ENV
          if [ "${image_exists}" == 1 ]
          then
            pull_latest=$(docker pull "${{ env.image_latest }}" > /dev/null; echo $?)
          fi

      - name: Validate values files
        if: ${{ env.image_exists == 1 }}
        uses: addnab/docker-run-action@v3
        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app
          run: |
            for file in /app/.k8s/*.yaml;
            do
              yamale -s /charts/generic-application/schema.yaml $file
            done

      - name: Docker build
        if: ${{ env.image_exists == 1 }}
        id: docker_build
        uses: docker/build-push-action@v2
        with:
          context: .
          file: Dockerfile
          build-args: |
            GITHUB_NPM_TOKEN=${{ secrets.GH_TOKEN }}
            build_number=${{ env.build_number }}
          push: false
          tags: "${{ env.image_name }}"

      - name: Trivy Scanning
        if: ${{ env.image_exists == 1 }}
        run: |
          docker run \
          -v /var/run/docker.sock:/var/run/docker.sock:rw \
          -v /trivy/cache:/tmp/trivy/db \
          aquasec/trivy:${{ secrets.TRIVY_VERSION }} \
          --cache-dir /tmp/trivy/ \
          --severity CRITICAL,HIGH \
          --no-progress \
          --ignore-unfixed \
          --exit-code 0 "${{ env.image_name }}"

      - name: Docker Push
        if: ${{ env.image_exists == 1 }}
        run: |
          branch=${GITHUB_REF#refs/heads/}
          docker push "${{ env.image_name }}"
          if [ $branch = "master" ]
          then
              docker tag "${{ env.image_name }}" "${{ env.image_latest }}"
              docker push "${{ env.image_latest }}"
          fi

  publish_to_stage:
    runs-on: ubuntu-latest
    needs: [ build_and_test ]
    env:
      build_number: ${{ needs.build_and_test.outputs.build_number }}
      branch: ${{ needs.build_and_test.outputs.branch }}
    outputs:
      namespace: ${{ env.namespace }}

    steps:

      - name: Set service name to GITHUB_ENV
        id: set_service_name
        run: |
          # этот шаг задублирован из джобы build_and_test, потому что гитхаб считает
          # что в нем лежит какой-то секрет и не даёт его передать в качестве аутпута
          # предыдущей джобы

          svc=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
          echo "service_name=$svc" >> $GITHUB_ENV

      - name: Get namespace name
        id: get_namespace
        run: |
          echo "Current branch is ${{ env.branch }}"
          namespace=$(echo ${{ env.branch }} | awk -F '/' '{print $NF}')
          namespace=${namespace,,}

          regexp='^|[a-z|]|[-a-z0-9|]{1,12}|[a-z0-9|]$'

          if echo $namespace | grep -Eq $regexp; then
              echo "${namespace} is valid name"
          else
            echo "Only: letters, numbers, no more than 14 characters";
            exit 1;
          fi

          echo "namespace=${namespace}" >> $GITHUB_ENV

      - uses: chrnorm/deployment-action@releases/v1
        name: Create GitHub deployment
        id: deployment
        with:
          token: "${{ secrets.GH_TOKEN }}"
          target_url: "http://${{ env.namespace }}.stage.yandex.sravni-team.ru"
          environment: staging

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Checkout source
        uses: actions/checkout@v2

      - name: Check if namespace already exists
        run: |
          RESPONSE_FILE=/tmp/$(uuidgen).txt

          qa_envs_route="${{ secrets.QA_API_URL }}/environments"
          env_name=${{ env.namespace }}

          get_response=$(curl -X GET -so "${RESPONSE_FILE}" -w "%{http_code}" ${qa_envs_route}/${env_name} \
          --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
          -H "accept: application/json" || true)

          namespace_exists=0

          if [ $get_response == "200" ]; then
           echo "Environment ${env_name} already exists"
           namespace_exists=1

          elif [ $get_response != "404" ]; then
           echo "Server returned:"
           cat "${RESPONSE_FILE}" && exit 1
          fi

          echo "namespace_exists=${namespace_exists}" >> $GITHUB_ENV

      - name: Create namespace
        if: ${{ env.namespace_exists == 0 }}
        uses: addnab/docker-run-action@v3
        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: -w=/charts/qa-environment-helpers
          run: |
            if [[ "${env_name}" != "master" ]]; then
              echo ${{ secrets.YANDEX_KEY }} | base64 --decode > /key.json

              yc config profile create github
              yc config set service-account-key /key.json
              yc managed-kubernetes \
                cluster get-credentials \
                --cloud-id ${{ secrets.YANDEX_CLOUD_ID }} \
                --folder-id ${{ secrets.YANDEX_FOLDER_ID }} \
                yc-stage-k8s --external

              RESPONSE_FILE=/tmp/$(uuidgen).txt

              qa_envs_route="${{ secrets.QA_API_URL }}/environments"
              env_name=${{ env.namespace }}

              put_response=$(curl -X PUT \
                -so "${RESPONSE_FILE}" \
                -w "%{http_code}" $qa_envs_route \
                -H "accept: application/json" \
                -H "Content-Type: application/json" \
                --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
                -d "{ \"createdBy\": \"${{ github.actor }}\", \"kind\": \"QA\", \"name\": \"${env_name}\", \"team\": \"${{ env.team }}\"}")

              if [ "${put_response}" != "200" ]; then
                echo "Cannot create environment ${env_name}"
                cat "${RESPONSE_FILE}" && exit 1
              fi

              echo "Environment ${env_name} has been created"
              # substitute the environment name inside the new-namespace-yandex.yml file
              export EnvironmentName=$env_name
              cat k8s-manifests/new-namespace-yandex.yml | envsubst | kubectl apply -f - 1>/dev/null 2>/dev/null
              echo "Manifest has been applied"

              /bin/bash /scripts/identity-key/new-identity-key.sh 1>/dev/null 2>/dev/null
              echo "Identity key has been generated"
              kubectl -n ${env_name} create secret generic identity-key --from-file identity.pfx 1>/dev/null 2>/dev/null
              echo "Identity key secret has been created"
              kubectl -n ${env_name} create secret generic labs-identity-key --from-file identity.pfx 1>/dev/null 2>/dev/null
              echo "Labs identity key secret has been created"
            fi

      - name: Publish
        uses: addnab/docker-run-action@v3

        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/helm-charts:${{ secrets.HELM_CHARTS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app -w=/app
          run: |
            echo ${{ secrets.YANDEX_KEY }} | base64 --decode > /key.json

            yc config profile create github
            yc config set service-account-key /key.json

            yc managed-kubernetes \
              cluster get-credentials \
              --cloud-id ${{ secrets.YANDEX_CLOUD_ID }} \
              --folder-id ${{ secrets.YANDEX_FOLDER_ID }} \
              yc-stage-k8s --external

            echo "Trying to deploy ${{ env.service_name }}..."

            werf helm upgrade --install \
              "${{ env.service_name }}" \
              --namespace "${{ env.namespace }}" \
              --timeout 10m \
              --wait \
              --set global.image.repository="${{ secrets.CONTAINER_REGISTRY }}/${{ env.service_name }}" \
              --set global.image.tag="${{ env.build_number }}" \
              --set global.imagePullSecrets[0]="${{ env.image_pull_secret_acr }}" \
              --set cronjobs.defaults.resources.enabled=false \
              --set resources.enabled=false \
              --set replicaCount=1 \
              -f ./.k8s/ya-stage.yaml \
              /charts/generic-application/ \
              2>&1

            if [ $? != 0 ]; then
              echo "Publish failed, see logs" && exit 1
            fi

            echo "Done"

      - name: Failed Deployment
        if: ${{ failure() }}
        run: echo "DEPLOY_STATE=failed" >> $GITHUB_ENV

      - name: Set info about deployment to qa-environment-service
        if: ${{ success() }}
        run: |
          echo "DEPLOY_STATE=success" >> $GITHUB_ENV

          qa_deps_route="${{ secrets.QA_API_URL }}/deployments"

          RESPONSE_FILE=/tmp/$(uuidgen).txt

          put_response=$(curl -X PUT \
            -so "${RESPONSE_FILE}" \
            -w "%{http_code}" "${qa_deps_route}" \
            -H "accept: application/json" \
            -H "Content-Type: application/json" \
            --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
            -d "{ \
               \"Branch\": \"${{ env.branch }}\", \
               \"Project\": \"${{ env.service_name }}\", \
               \"Stand\": \"${{ env.namespace }}\", \
               \"TriggeredBy\": \"${{ github.actor }}\", \
               \"VcsNumber\": \"${{ env.build_number }}\", \
               \"buildId\": ${{ github.run_id }} \
               }" \
          || true )

          if [ "${put_response}" == "200" ]; then
            echo "Deployment creation OK"
            exit 0
          elif [ "${put_response}" == "409" ]; then
            echo "Deployment already exists"
            exit 0
          else
            echo "Cannot create deployment"
            echo "${put_response}"
            cat "${RESPONSE_FILE}" && exit 1
          fi

      - name: Update deployment status
        if: ${{ success() || failure() }}
        uses: chrnorm/deployment-status@releases/v1
        with:
          token: "${{ secrets.GH_TOKEN }}"
          target_url: "http://${{ env.namespace }}.stage.yandex.sravni-team.ru"
          state: "${{ env.DEPLOY_STATE }}"
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}

  run_e2e_tests:

    if: startsWith(github.ref, 'delete the stopper')
    runs-on: ubuntu-latest
    # runs-on: sravni_ycloud_stage, если тестам нужен доступ к инфре
    needs:
      - publish_to_stage

    env:
      namespace: ${{ needs.publish_to_stage.outputs.namespace }}

    steps:
      - uses: actions/checkout@v2

      - name: Set tags
        run: |
          image_tag=pw-tests:$(date +%s)
          echo "image_tag=$image_tag" >> $GITHUB_ENV

      - name: Set base_url
        run: |
          base_url="http://${{ env.namespace }}.stage.yandex.sravni-team.ru"
          echo "base_url=$base_url" >> $GITHUB_ENV

      - name: Docker build
        uses: docker/build-push-action@v2
        with:
          context: .
          file: e2e.Dockerfile
          build-args: |
            GITHUB_NPM_TOKEN=${{ secrets.GH_TOKEN }}
          tags: ${{ env.image_tag }}

      - name: Run the tests
        run: |
          docker run --rm -i -e BASE_URL=${{ env.base_url }} ${{ env.image_tag }}

  publish_to_azure:
    if: startsWith(github.ref, 'refs/tags') || contains(github.event_name, 'release')

    needs:
      - 'build_and_test'
      - 'publish_to_stage'

    runs-on: ubuntu-latest

    env:
      author: ${{ needs.build_and_test.outputs.author }}
      branch: ${{ needs.build_and_test.outputs.branch }}
      committer: ${{ needs.build_and_test.outputs.committer }}
      build_number: ${{ needs.build_and_test.outputs.build_number }}

    steps:
      - name: Set service name to GITHUB_ENV
        id: set_service_name
        run: |
          # этот шаг задублирован из джобы build_and_test, потому что гитхаб считает
          # что в нем лежит какой-то секрет и не даёт его передать в качестве аутпута
          # предыдущей джобы

          svc=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
          echo "service_name=$svc" >> $GITHUB_ENV

      - uses: chrnorm/deployment-action@releases/v1
        name: Create GitHub deployment
        id: deployment
        with:
          token: "${{ secrets.GH_TOKEN }}"
          target_url: "http://${{ env.namespace }}.stage.yandex.sravni-team.ru"
          environment: production

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Checkout source
        uses: actions/checkout@v2

      - name: Publish
        uses: addnab/docker-run-action@v3

        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app -w=/app
          run: |
            az login --service-principal \
              --username ${{ secrets.ARM_CLIENT_ID }} \
              --password ${{ secrets.ARM_CLIENT_SECRET }} \
              --tenant ${{ secrets.ARM_TENANT_ID }}

            az aks get-credentials --admin \
              --resource-group sravni \
              --name az-prod-k8s
            echo "Deploying service ${{ env.service_name }}..."

            werf helm upgrade --install \
             "${{ env.service_name }}" \
             --namespace sravni \
             --atomic \
             --timeout 10m \
             --set global.image.repository="${{ secrets.CONTAINER_REGISTRY }}/${{ env.service_name }}" \
             --set global.image.tag="${{ env.build_number }}" \
             --set global.imagePullSecrets[0]="${{ env.image_pull_secret_acr }}" \
             --set azureRedis.uri=${{ secrets.AZURE_REDIS_URI }} \
             --set linkerd.enabled=false \
             -f ./.k8s/azure.yaml \
             /charts/generic-application/

            if [ $? != 0 ]; then
              echo "Publish failed, see logs" && exit 1
            fi

            echo "Done"

      - name: Build deployment name
        if: ${{ always() }}
        run: |
          dep_url="${{ github.event.repository.url }}/actions/runs/${{ github.run_id }}"
          title="@${{env.committer}} опубликовал(а) релиз \`${{env.service_name}}\`"
          title+=" версии <${dep_url}|'${{env.build_number}}'> из ветки \`${{env.branch}}\`"
          echo "DEPLOY_NAME=${title}" >> $GITHUB_ENV

      - name: Successful Deployment
        if: ${{ success() }}
        run: echo "DEPLOY_STATE=success" >> $GITHUB_ENV

      - name: Failed Deployment
        if: ${{ failure() }}
        run: echo "DEPLOY_STATE=failure" >> $GITHUB_ENV

      - name: Update deployment status
        if: ${{ success() || failure() }}
        uses: chrnorm/deployment-status@releases/v1
        with:
          token: "${{ secrets.GH_TOKEN }}"
          target_url: "${{ github.event.repository.url }}/actions/runs/${{ github.run_id }}"
          state: "${{ env.DEPLOY_STATE }}"
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
