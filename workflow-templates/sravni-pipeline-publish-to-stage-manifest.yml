name: Publish-to-Stage-Manifest

#Запуск на любой пуш в мастер ветку или на создание/редактирование ПРа
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
    types: [opened, edited]

env:
  #Переменная для определения пренадлежности к команде, задается в secrets репозитория
  team: platform
  image_pull_secret_acr: sravni-azurecr-io

jobs:
  prepublish:
    runs-on: sravni_ycloud_stage

    outputs:
      branch: ${{ env.branch }}
      service_name: ${{ env.service_name }}
      build_number: ${{ env.build_number }}

    steps:
      - name: Checkout source
        uses: actions/checkout@v2

      - name: Setup docker context for buildx
        id: buildx-context
        run: |
          docker context create builders

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
        with:
          endpoint: builders
          driver: kubernetes

      #Шаги получения имени бранча
      #Если это ПР, то берем ветку из которой он открыт
      - name: Get branch name (merge)
        if: github.event_name != 'pull_request'
        run: echo "branch=$(echo ${GITHUB_REF#refs/heads/} | tr / -)" >> $GITHUB_ENV

      - name: Get branch name (pull request)
        if: github.event_name == 'pull_request'
        run: echo "branch=$(echo ${GITHUB_HEAD_REF} | tr / -)" >> $GITHUB_ENV

      #Шаг получения необходимых переменных для работы пайплайна
      #service_name - получается из имени репозитория, например osago-frontend
      #build_number - тег нашего образа, состоит из sha коммита и постфикса qa для стейдж окружения, для прода постфикс отсутствует
      #image_name - полное имя образа, к примеру sravni.azurecr.io/osago-frontend:ha751ufq
      - name: Set build vars to GITHUB_ENV
        run: |
          service_name=$(basename `git rev-parse --show-toplevel`)
          sha=$(echo ${GITHUB_SHA} | cut -c1-7)
          build_number=$sha-qa
          image_name="${{ secrets.CONTAINER_REGISTRY }}/${service_name}-service:${build_number}"
          echo "service_name=$service_name" >> $GITHUB_ENV
          echo "build_number=$build_number" >> $GITHUB_ENV
          echo "image_name=$image_name" >> $GITHUB_ENV

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      #Сборка образа с пушем его в реджестри
      - name: Docker build
        id: docker_build
        uses: docker/build-push-action@v2
        with:
          context: .
          file: Dockerfile
          build-args: |
            GITHUB_NPM_TOKEN=${{ secrets.GH_TOKEN }}
            build_number=${{ env.build_number }}
            GITHUB_USERNAME=sravni
            GITHUB_TOKEN=${{ secrets.GH_TOKEN }}
          push: true
          tags: "${{ env.image_name }}"

  publish:
    runs-on: ubuntu-latest
    needs: [ prepublish ]

    env:
      build_number: ${{ needs.prepublish.outputs.build_number }}
      branch: ${{ needs.prepublish.outputs.branch }}
      service_name: ${{ needs.prepublish.outputs.service_name }}

    #Шаг получения имени неймспейса
    #Имя неймспейса образуется из названия ветки, не должно содержать спецсимволов
    #и должно быть не более 14 символов
    steps:
      - name: Get namespace name
        id: get_namespace
        run: |
          echo "Current branch is ${{ env.branch }}"
          namespace=$(echo ${{ env.branch }} | awk -F '/' '{print $NF}')
          namespace=${namespace,,}
          regexp='^|[a-z|]|[-a-z0-9|]{1,12}|[a-z0-9|]$'
          if echo $namespace | grep -Eq $regexp; then
              echo "${namespace} is valid name"
          else
            echo "Only: letters, numbers, no more than 14 characters";
            exit 1;
          fi
          echo "namespace=${namespace}" >> $GITHUB_ENV

      - name: Login to ACR
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Checkout source
        uses: actions/checkout@v2

      #Шаг получения проверки существования неймспейса в qa-dashboard
      - name: Check if namespace already exists
        run: |
          RESPONSE_FILE=/tmp/$(uuidgen).txt
          qa_envs_route="${{ secrets.QA_API_URL }}/environments"
          get_response=$(curl -X GET -so "${RESPONSE_FILE}" -w "%{http_code}" ${qa_envs_route}/${{ env.namespace }} \
          --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
          -H "accept: application/json")
          namespace_exists=0
          if [ $get_response == "200" ]; then
           echo "Environment ${{ env.namespace }} already exists"
           namespace_exists=1
          elif [ $get_response != "404" ]; then
           echo "Server returned:"
           cat "${RESPONSE_FILE}" && exit 1
          fi
          echo "namespace_exists=${namespace_exists}" >> $GITHUB_ENV

      #Шаг создания неймспейса и всех необходимых для его работоспособности секретов
      - name: Create namespace
        if: ${{ env.namespace_exists == 0 }}
        uses: addnab/docker-run-action@v3
        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/qa-environment-helpers:${{ secrets.QA_ENVIRONMENT_HELPERS_TAG }}
          options: -w=/charts/qa-environment-helpers
          run: |
            echo ${{ secrets.YANDEX_KEY }} | base64 --decode > /key.json
            yc config profile create github
            yc config set service-account-key /key.json
            yc managed-kubernetes \
              cluster get-credentials \
              --cloud-id ${{ secrets.YANDEX_CLOUD_ID }} \
              --folder-id ${{ secrets.YANDEX_FOLDER_ID }} \
              yc-stage-k8s --external
            RESPONSE_FILE=/tmp/$(uuidgen).txt
            qa_envs_route="${{ secrets.QA_API_URL }}/environments"
            put_response=$(curl -X PUT \
              -so "${RESPONSE_FILE}" \
              -w "%{http_code}" $qa_envs_route \
              -H "accept: application/json" \
              -H "Content-Type: application/json" \
              --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
              -d "{ \"createdBy\": \"${{ github.actor }}\", \"kind\": \"QA\", \"name\": \"${{ env.namespace }}\", \"team\": \"${{ secrets.TEAM }}\"}")
            if [ "${put_response}" != "200" ]; then
              echo "Cannot create environment ${{ env.namespace }}"
              cat "${RESPONSE_FILE}" && exit 1
            fi
            echo "Environment ${{ env.namespace }} has been created"
            export EnvironmentName=${{ env.namespace }}
            cat k8s-manifests/new-namespace-yandex.yml | envsubst | kubectl apply -f -
            echo "Manifest has been applied"
            /bin/bash /charts/qa-environment-helpers/scripts/identity-key/new-identity-key.sh
            echo "Identity key has been generated"
            kubectl -n ${{ env.namespace }} create secret generic identity-key --from-file identity.pfx
            echo "Identity key secret has been created"
            kubectl -n ${{ env.namespace }} create secret generic labs-identity-key --from-file identity.pfx
            echo "Labs identity key secret has been created"

      #Шаг деплоя приложения в Stage
      - name: Publish
        uses: addnab/docker-run-action@v3
        with:
          username: ${{ secrets.DOCKER_LOGIN }}
          password: ${{ secrets.DOCKER_PASS }}
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          image: ${{ secrets.CONTAINER_REGISTRY }}/helm-charts:${{ secrets.HELM_CHARTS_TAG }}
          options: --rm -i -v ${{ github.workspace }}:/app -w=/app
          run: |
            echo ${{ secrets.YANDEX_KEY }} | base64 --decode > /key.json
            yc config profile create github
            yc config set service-account-key /key.json
            yc managed-kubernetes \
              cluster get-credentials \
              --cloud-id ${{ secrets.YANDEX_CLOUD_ID }} \
              --folder-id ${{ secrets.YANDEX_FOLDER_ID }} \
              yc-stage-k8s --external
            echo "Trying to deploy ${{ env.service_name }}..."
            export IMAGE_VERSION=${{ env.build_number }}
            echo $IMAGE_VERSION
            export DEPLOY_NAMESPACE=${{ env.namespace }}
            echo $DEPLOY_NAMESPACE
            cat /app/k8s/ya-stage.yaml | envsubst | kubectl apply -f -

      #Шаг отправки информации в qa-enviroment-service
      - name: Set info about deployment to qa-environment-service
        if: ${{ success() }}
        run: |
          echo "DEPLOY_STATE=successful" >> $GITHUB_ENV
          qa_deps_route="${{ secrets.QA_API_URL }}/deployments"
          RESPONSE_FILE=/tmp/$(uuidgen).txt
          put_response=$(curl -X PUT \
            -so "${RESPONSE_FILE}" \
            -w "%{http_code}" "${qa_deps_route}" \
            -H "accept: application/json" \
            -H "Content-Type: application/json" \
            --cookie "${{ secrets.YA_AUTH_COOKIE_NAME_VALUE }}" \
            -d "{ \
               \"Branch\": \"${{ env.branch }}\", \
               \"Project\": \"${{ env.service_name }}\", \
               \"Stand\": \"${{ env.namespace }}\", \
               \"TriggeredBy\": \"${{ github.actor }}\", \
               \"VcsNumber\": \"${{ env.build_number }}\", \
               \"buildId\": ${{ github.run_id }} \
               }")
          if [ "${put_response}" == "200" ]; then
            echo "Deployment creation OK"
            exit 0
          elif [ "${put_response}" == "409" ]; then
            echo "Deployment already exists"
            exit 0
          else
            echo "Cannot create deployment"
            echo "${put_response}"
            cat "${RESPONSE_FILE}" && exit 1
          fi
